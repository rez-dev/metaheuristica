for (j in 1:length(solution)) {
cost <- cost + Q_matrix[i, j] * distance_matrix[solution[i], solution[j]]
}
}
# Retornar el costo de la solución
return(cost)
}
# Función para generar un vecino aleatorio de una solución
generate_neighbor <- function(solution) {
# Seleccionar dos índices aleatorios
i <- sample(1:length(solution), 1)
j <- sample(1:length(solution), 1)
# Intercambiar los valores de los dos índices
new_solution <- solution
new_solution[i] <- solution[j]
new_solution[j] <- solution[i]
# Retornar el vecino aleatorio generado
return(new_solution)
}
# Función para verificar si una solución está en la lista tabu
is_tabu <- function(solution, tabu_list) {
# Retornar TRUE si la solución está en la lista tabu, FALSE en caso contrario
return(any(solution %in% tabu_list))
}
# Función para actualizar la lista tabu
update_tabu_list <- function(tabu_list, solution) {
# Agregar la solución a la lista tabu
tabu_list <- append(tabu_list, solution)
# Si la lista tabu supera el tamaño máximo, eliminar la solución más antigua
if (length(tabu_list) > tabu_size) {
tabu_list <- tabu_list[-1]
}
# Retornar la lista tabu actualizada
return(tabu_list)
}
# Función principal del algoritmo de búsqueda tabu
tabu_search <- function(Q_matrix, distance_matrix) {
# Inicializar la solución actual y la lista tabu
current_solution <- sample(1:length(distance_matrix), length(distance_matrix))
tabu_list <- list()
# Iniciar el ciclo de iteraciones
for (i in 1:max_iter) {
# Generar un vecino aleatorio de la solución actual
new_solution <- generate_neighbor(current_solution)
# Si el vecino aleatorio no está en la lista tabu y es mejor que la solución actual, aceptarlo
if (!is_tabu(new_solution, tabu_list) && evaluate(new_solution) < evaluate(current_solution)) {
current_solution <- new_solution
}
# Actualizar la lista tabu
tabu_list <- update_tabu_list(tabu_list, new_solution)
}
# Retornar la solución actual
return(current_solution)
}
# instancia<-readQAP("instancia.dat")
# # set.seed(111)
# flow_matrix <- instancia$f
# distance_matrix <- instancia$d
tic("Tabu Search")
result <- tabu_search(flow_matrix, distance_matrix)
cat("Mejor solución encontrada:", result, "\n")
# cat("Costo de la mejor solución:", result$cost, "\n")
toc()
fitness<-evaluarQAP(result,instancia$f,instancia$d)
fitness
readQAP<-function(name){
a <- read.delim(name,header=FALSE, sep ="")
n<-as.integer(a[1,1])
fl<-a[2:(n+1),1:n]
dis<-a[(n+2):(n+n+1),1:n]
d <- list(n=n, f= fl, d = dis)
return(d)
}
evaluarQAP<-function(sol, f, d){
acum<-0
n<-length(sol)
for(i in 1:n){
for(j in 1:n){
acum = acum + f[i,j]*d[sol[i],sol[j]]
}
}
return(acum)
}
# Algoritmo de Búsqueda Tabú para el Problema de Asignación Cuadrática (QAP)
# Parámetros del algoritmo
instancia<-readQAP("instancia.dat")
tabu_size <- 10 # Tamaño de la lista tabu
max_iter <- 100 # Número máximo de iteraciones
Q_matrix <- instancia$f
distance_matrix <- instancia$d
# Función para evaluar una solución
evaluate <- function(solution) {
# Calcular el costo de la solución
cost <- 0
for (i in 1:length(solution)) {
for (j in 1:length(solution)) {
cost <- cost + Q_matrix[i, j] * distance_matrix[solution[i], solution[j]]
}
}
# Retornar el costo de la solución
return(cost)
}
# Función para generar un vecino aleatorio de una solución
generate_neighbor <- function(solution) {
# Seleccionar dos índices aleatorios
i <- sample(1:length(solution), 1)
j <- sample(1:length(solution), 1)
# Intercambiar los valores de los dos índices
new_solution <- solution
new_solution[i] <- solution[j]
new_solution[j] <- solution[i]
# Retornar el vecino aleatorio generado
return(new_solution)
}
# Función para verificar si una solución está en la lista tabu
is_tabu <- function(solution, tabu_list) {
# Retornar TRUE si la solución está en la lista tabu, FALSE en caso contrario
return(any(solution %in% tabu_list))
}
# Función para actualizar la lista tabu
update_tabu_list <- function(tabu_list, solution) {
# Agregar la solución a la lista tabu
tabu_list <- append(tabu_list, solution)
# Si la lista tabu supera el tamaño máximo, eliminar la solución más antigua
if (length(tabu_list) > tabu_size) {
tabu_list <- tabu_list[-1]
}
# Retornar la lista tabu actualizada
return(tabu_list)
}
# Función principal del algoritmo de búsqueda tabu
tabu_search <- function(Q_matrix, distance_matrix) {
# Inicializar la solución actual y la lista tabu
current_solution <- sample(1:length(distance_matrix), length(distance_matrix))
tabu_list <- list()
# Iniciar el ciclo de iteraciones
for (i in 1:max_iter) {
# Generar un vecino aleatorio de la solución actual
new_solution <- generate_neighbor(current_solution)
# Si el vecino aleatorio no está en la lista tabu y es mejor que la solución actual, aceptarlo
if (!is_tabu(new_solution, tabu_list) && evaluate(new_solution) < evaluate(current_solution)) {
current_solution <- new_solution
}
# Actualizar la lista tabu
tabu_list <- update_tabu_list(tabu_list, new_solution)
}
# Retornar la solución actual
return(current_solution)
}
# instancia<-readQAP("instancia.dat")
# # set.seed(111)
# flow_matrix <- instancia$f
# distance_matrix <- instancia$d
tic("Tabu Search")
result <- tabu_search(flow_matrix, distance_matrix)
cat("Mejor solución encontrada:", result, "\n")
# cat("Costo de la mejor solución:", result$cost, "\n")
toc()
fitness<-evaluarQAP(result,instancia$f,instancia$d)
fitness
readQAP<-function(name){
a <- read.delim(name,header=FALSE, sep ="")
n<-as.integer(a[1,1])
fl<-a[2:(n+1),1:n]
dis<-a[(n+2):(n+n+1),1:n]
d <- list(n=n, f= fl, d = dis)
return(d)
}
evaluarQAP<-function(sol, f, d){
acum<-0
n<-length(sol)
for(i in 1:n){
for(j in 1:n){
acum = acum + f[i,j]*d[sol[i],sol[j]]
}
}
return(acum)
}
# Algoritmo de Búsqueda Tabú para el Problema de Asignación Cuadrática (QAP)
# Parámetros del algoritmo
instancia<-readQAP("instancia.dat")
tabu_size <- 10 # Tamaño de la lista tabu
max_iter <- 1000 # Número máximo de iteraciones
Q_matrix <- instancia$f
distance_matrix <- instancia$d
# Función para evaluar una solución
evaluate <- function(solution) {
# Calcular el costo de la solución
cost <- 0
for (i in 1:length(solution)) {
for (j in 1:length(solution)) {
cost <- cost + Q_matrix[i, j] * distance_matrix[solution[i], solution[j]]
}
}
# Retornar el costo de la solución
return(cost)
}
# Función para generar un vecino aleatorio de una solución
generate_neighbor <- function(solution) {
# Seleccionar dos índices aleatorios
i <- sample(1:length(solution), 1)
j <- sample(1:length(solution), 1)
# Intercambiar los valores de los dos índices
new_solution <- solution
new_solution[i] <- solution[j]
new_solution[j] <- solution[i]
# Retornar el vecino aleatorio generado
return(new_solution)
}
# Función para verificar si una solución está en la lista tabu
is_tabu <- function(solution, tabu_list) {
# Retornar TRUE si la solución está en la lista tabu, FALSE en caso contrario
return(any(solution %in% tabu_list))
}
# Función para actualizar la lista tabu
update_tabu_list <- function(tabu_list, solution) {
# Agregar la solución a la lista tabu
tabu_list <- append(tabu_list, solution)
# Si la lista tabu supera el tamaño máximo, eliminar la solución más antigua
if (length(tabu_list) > tabu_size) {
tabu_list <- tabu_list[-1]
}
# Retornar la lista tabu actualizada
return(tabu_list)
}
# Función principal del algoritmo de búsqueda tabu
tabu_search <- function(Q_matrix, distance_matrix) {
# Inicializar la solución actual y la lista tabu
current_solution <- sample(1:length(distance_matrix), length(distance_matrix))
tabu_list <- list()
# Iniciar el ciclo de iteraciones
for (i in 1:max_iter) {
# Generar un vecino aleatorio de la solución actual
new_solution <- generate_neighbor(current_solution)
# Si el vecino aleatorio no está en la lista tabu y es mejor que la solución actual, aceptarlo
if (!is_tabu(new_solution, tabu_list) && evaluate(new_solution) < evaluate(current_solution)) {
current_solution <- new_solution
}
# Actualizar la lista tabu
tabu_list <- update_tabu_list(tabu_list, new_solution)
}
# Retornar la solución actual
return(current_solution)
}
# instancia<-readQAP("instancia.dat")
# # set.seed(111)
# flow_matrix <- instancia$f
# distance_matrix <- instancia$d
tic("Tabu Search")
result <- tabu_search(flow_matrix, distance_matrix)
cat("Mejor solución encontrada:", result, "\n")
# cat("Costo de la mejor solución:", result$cost, "\n")
toc()
fitness<-evaluarQAP(result,instancia$f,instancia$d)
fitness
readQAP<-function(name){
a <- read.delim(name,header=FALSE, sep ="")
n<-as.integer(a[1,1])
fl<-a[2:(n+1),1:n]
dis<-a[(n+2):(n+n+1),1:n]
d <- list(n=n, f= fl, d = dis)
return(d)
}
evaluarQAP<-function(sol, f, d){
acum<-0
n<-length(sol)
for(i in 1:n){
for(j in 1:n){
acum = acum + f[i,j]*d[sol[i],sol[j]]
}
}
return(acum)
}
# Algoritmo de Búsqueda Tabú para el Problema de Asignación Cuadrática (QAP)
# Parámetros del algoritmo
instancia<-readQAP("instancia.dat")
tabu_size <- 10 # Tamaño de la lista tabu
max_iter <- 1000 # Número máximo de iteraciones
Q_matrix <- instancia$f
distance_matrix <- instancia$d
# Función para evaluar una solución
evaluate <- function(solution) {
# Calcular el costo de la solución
cost <- 0
for (i in 1:length(solution)) {
for (j in 1:length(solution)) {
cost <- cost + Q_matrix[i, j] * distance_matrix[solution[i], solution[j]]
}
}
# Retornar el costo de la solución
return(cost)
}
# Función para generar un vecino aleatorio de una solución
generate_neighbor <- function(solution) {
# Seleccionar dos índices aleatorios
i <- sample(1:length(solution), 1)
j <- sample(1:length(solution), 1)
# Intercambiar los valores de los dos índices
new_solution <- solution
new_solution[i] <- solution[j]
new_solution[j] <- solution[i]
# Retornar el vecino aleatorio generado
return(new_solution)
}
# Función para verificar si una solución está en la lista tabu
is_tabu <- function(solution, tabu_list) {
# Retornar TRUE si la solución está en la lista tabu, FALSE en caso contrario
return(any(solution %in% tabu_list))
}
# Función para actualizar la lista tabu
update_tabu_list <- function(tabu_list, solution) {
# Agregar la solución a la lista tabu
tabu_list <- append(tabu_list, solution)
# Si la lista tabu supera el tamaño máximo, eliminar la solución más antigua
if (length(tabu_list) > tabu_size) {
tabu_list <- tabu_list[-1]
}
# Retornar la lista tabu actualizada
return(tabu_list)
}
# Función principal del algoritmo de búsqueda tabu
tabu_search <- function(Q_matrix, distance_matrix) {
# Inicializar la solución actual y la lista tabu
current_solution <- sample(1:length(distance_matrix), length(distance_matrix))
tabu_list <- list()
# Iniciar el ciclo de iteraciones
for (i in 1:max_iter) {
# Generar un vecino aleatorio de la solución actual
new_solution <- generate_neighbor(current_solution)
# Si el vecino aleatorio no está en la lista tabu y es mejor que la solución actual, aceptarlo
if (!is_tabu(new_solution, tabu_list) && evaluate(new_solution) < evaluate(current_solution)) {
current_solution <- new_solution
}
# Actualizar la lista tabu
tabu_list <- update_tabu_list(tabu_list, new_solution)
}
# Retornar la solución actual
return(current_solution)
}
# instancia<-readQAP("instancia.dat")
# # set.seed(111)
# flow_matrix <- instancia$f
# distance_matrix <- instancia$d
tic("Tabu Search")
result <- tabu_search(flow_matrix, distance_matrix)
cat("Mejor solución encontrada:", result, "\n")
# cat("Costo de la mejor solución:", result$cost, "\n")
toc()
fitness<-evaluarQAP(result,instancia$f,instancia$d)
fitness
readQAP<-function(name){
a <- read.delim(name,header=FALSE, sep ="")
n<-as.integer(a[1,1])
fl<-a[2:(n+1),1:n]
dis<-a[(n+2):(n+n+1),1:n]
d <- list(n=n, f= fl, d = dis)
return(d)
}
evaluarQAP<-function(sol, f, d){
acum<-0
n<-length(sol)
for(i in 1:n){
for(j in 1:n){
acum = acum + f[i,j]*d[sol[i],sol[j]]
}
}
return(acum)
}
# Algoritmo de Búsqueda Tabú para el Problema de Asignación Cuadrática (QAP)
# Parámetros del algoritmo
instancia<-readQAP("instancia.dat")
tabu_size <- 100 # Tamaño de la lista tabu
max_iter <- 10000 # Número máximo de iteraciones
Q_matrix <- instancia$f
distance_matrix <- instancia$d
# Función para evaluar una solución
evaluate <- function(solution) {
# Calcular el costo de la solución
cost <- 0
for (i in 1:length(solution)) {
for (j in 1:length(solution)) {
cost <- cost + Q_matrix[i, j] * distance_matrix[solution[i], solution[j]]
}
}
# Retornar el costo de la solución
return(cost)
}
# Función para generar un vecino aleatorio de una solución
generate_neighbor <- function(solution) {
# Seleccionar dos índices aleatorios
i <- sample(1:length(solution), 1)
j <- sample(1:length(solution), 1)
# Intercambiar los valores de los dos índices
new_solution <- solution
new_solution[i] <- solution[j]
new_solution[j] <- solution[i]
# Retornar el vecino aleatorio generado
return(new_solution)
}
# Función para verificar si una solución está en la lista tabu
is_tabu <- function(solution, tabu_list) {
# Retornar TRUE si la solución está en la lista tabu, FALSE en caso contrario
return(any(solution %in% tabu_list))
}
# Función para actualizar la lista tabu
update_tabu_list <- function(tabu_list, solution) {
# Agregar la solución a la lista tabu
tabu_list <- append(tabu_list, solution)
# Si la lista tabu supera el tamaño máximo, eliminar la solución más antigua
if (length(tabu_list) > tabu_size) {
tabu_list <- tabu_list[-1]
}
# Retornar la lista tabu actualizada
return(tabu_list)
}
# Función principal del algoritmo de búsqueda tabu
tabu_search <- function(Q_matrix, distance_matrix) {
# Inicializar la solución actual y la lista tabu
current_solution <- sample(1:length(distance_matrix), length(distance_matrix))
tabu_list <- list()
# Iniciar el ciclo de iteraciones
for (i in 1:max_iter) {
# Generar un vecino aleatorio de la solución actual
new_solution <- generate_neighbor(current_solution)
# Si el vecino aleatorio no está en la lista tabu y es mejor que la solución actual, aceptarlo
if (!is_tabu(new_solution, tabu_list) && evaluate(new_solution) < evaluate(current_solution)) {
current_solution <- new_solution
}
# Actualizar la lista tabu
tabu_list <- update_tabu_list(tabu_list, new_solution)
}
# Retornar la solución actual
return(current_solution)
}
# instancia<-readQAP("instancia.dat")
# # set.seed(111)
# flow_matrix <- instancia$f
# distance_matrix <- instancia$d
tic("Tabu Search")
result <- tabu_search(flow_matrix, distance_matrix)
# Algoritmo de Búsqueda Tabú para el Problema de Asignación Cuadrática (QAP)
# Parámetros del algoritmo
instancia<-readQAP("instancia.dat")
tabu_size <- 100 # Tamaño de la lista tabu
max_iter <- 10000 # Número máximo de iteraciones
Q_matrix <- instancia$f
distance_matrix <- instancia$d
# Función para evaluar una solución
evaluate <- function(solution) {
# Calcular el costo de la solución
cost <- 0
for (i in 1:length(solution)) {
for (j in 1:length(solution)) {
cost <- cost + Q_matrix[i, j] * distance_matrix[solution[i], solution[j]]
}
}
# Retornar el costo de la solución
return(cost)
}
# Función para generar un vecino aleatorio de una solución
generate_neighbor <- function(solution) {
# Seleccionar dos índices aleatorios
i <- sample(1:length(solution), 1)
j <- sample(1:length(solution), 1)
# Intercambiar los valores de los dos índices
new_solution <- solution
new_solution[i] <- solution[j]
new_solution[j] <- solution[i]
# Retornar el vecino aleatorio generado
return(new_solution)
}
# Función para verificar si una solución está en la lista tabu
is_tabu <- function(solution, tabu_list) {
# Retornar TRUE si la solución está en la lista tabu, FALSE en caso contrario
return(any(solution %in% tabu_list))
}
# Función para actualizar la lista tabu
update_tabu_list <- function(tabu_list, solution) {
# Agregar la solución a la lista tabu
tabu_list <- append(tabu_list, solution)
# Si la lista tabu supera el tamaño máximo, eliminar la solución más antigua
if (length(tabu_list) > tabu_size) {
tabu_list <- tabu_list[-1]
}
# Retornar la lista tabu actualizada
return(tabu_list)
}
# Función principal del algoritmo de búsqueda tabu
tabu_search <- function(Q_matrix, distance_matrix) {
# Inicializar la solución actual y la lista tabu
current_solution <- sample(1:length(distance_matrix), length(distance_matrix))
tabu_list <- list()
# Iniciar el ciclo de iteraciones
for (i in 1:max_iter) {
# Generar un vecino aleatorio de la solución actual
new_solution <- generate_neighbor(current_solution)
# Si el vecino aleatorio no está en la lista tabu y es mejor que la solución actual, aceptarlo
if (!is_tabu(new_solution, tabu_list) && evaluate(new_solution) < evaluate(current_solution)) {
current_solution <- new_solution
}
# Actualizar la lista tabu
tabu_list <- update_tabu_list(tabu_list, new_solution)
}
# Retornar la solución actual
return(current_solution)
}
# instancia<-readQAP("instancia.dat")
# # set.seed(111)
# flow_matrix <- instancia$f
# distance_matrix <- instancia$d
tic("Tabu Search")
result <- tabu_search(flow_matrix, distance_matrix)
